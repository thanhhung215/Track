name: Build Qt Application

on:
  push:
    branches: [ main ]
    tags:
      - 'v*'
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: windows-latest

    steps:
    - uses: actions/checkout@v3

    - name: Install Qt
      uses: jurplel/install-qt-action@v3
      with:
        version: '6.5.3'
        host: 'windows'
        target: 'desktop'
        arch: 'win64_msvc2019_64'
        tools: 'tools_qtcreator'
        modules: 'qtwebsockets qtwebchannel qtwebengine qtwebview qthttpserver qtmultimedia'
        cache: true

    - name: Set up MSVC
      uses: microsoft/setup-msbuild@v1.1

    - name: Setup Visual Studio Environment
      uses: ilammy/msvc-dev-cmd@v1
      with:
        arch: x64

    # Build Server
    - name: Create Server Build Directory
      run: |
        if (Test-Path build) { Remove-Item build -Recurse -Force }
        mkdir build
      working-directory: Server

    - name: Configure Server QMake
      run: |
        qmake ..\Server.pro -spec win32-msvc "CONFIG+=test"
      working-directory: Server/build

    - name: Build Server
      run: |
        nmake
      working-directory: Server/build

    - name: Deploy Server
      run: |
        if (Test-Path deploy) { Remove-Item deploy -Recurse -Force }
        mkdir deploy
        copy build\release\Server.exe deploy\
        windeployqt deploy\Server.exe
      working-directory: Server

    # Test Server
    - name: Test Server
      run: |
        # Start Server with output redirection and wait for output
        $serverProcess = Start-Process -FilePath "deploy\Server.exe" -WorkingDirectory "deploy" -PassThru -RedirectStandardOutput "server_output.log" -RedirectStandardError "server_error.log" -NoNewWindow
        
        Write-Host "Server process started with PID: $($serverProcess.Id)"
        Write-Host "Waiting for server to initialize..."
        
        # Wait and check for server startup in logs
        $maxWait = 30
        $waited = 0
        $serverStarted = $false
        while ($waited -lt $maxWait -and -not $serverStarted) {
            if (Get-Content "server_output.log" | Select-String "HTTP server is listening on port") {
                $serverStarted = $true
                Write-Host "Server startup detected in logs"
                break
            }
            # Also check for TCP server startup
            if (Get-Content "server_output.log" | Select-String "Server started!") {
                Write-Host "TCP Server startup detected"
            }
            
            # Show current log content
            Write-Host "Current log content (${waited}s):"
            Get-Content "server_output.log"
            
            Start-Sleep -Seconds 1
            $waited++
        }
        
        if (-not $serverStarted) {
            Write-Error "Server did not start properly within $maxWait seconds"
            Write-Host "Final log content:"
            Write-Host "Server stdout:"
            Get-Content "server_output.log"
            Write-Host "Server stderr:"
            Get-Content "server_error.log"
            Write-Host "Process status:"
            Get-Process | Where-Object { $_.Id -eq $serverProcess.Id } | Format-List
            exit 1
        }
        
        # Display network information
        Write-Host "Network interfaces:"
        ipconfig /all
        
        Write-Host "Active TCP Listeners:"
        netstat -ano | Select-String "LISTENING"
        
        # Try different addresses
        $addresses = @(
            "localhost",
            "127.0.0.1",
            "0.0.0.0",
            $env:COMPUTERNAME,
            (Get-NetIPAddress -AddressFamily IPv4 | Where-Object { $_.InterfaceAlias -eq "Ethernet" }).IPAddress
        )
        
        $success = $false
        foreach ($addr in $addresses) {
            Write-Host "Testing connection to $addr`:8080"
            try {
                $response = Invoke-WebRequest -Uri "http://$addr`:8080" -TimeoutSec 5
                if ($response.StatusCode -eq 200) {
                    Write-Host "Successfully connected to $addr`:8080"
                    Write-Host "Response: $($response.Content)"
                    $success = $true
                    break
                }
            }
            catch {
                Write-Host "Failed to connect to $addr`:8080: $_"
            }
        }
        
        # Kill Server process
        Stop-Process -Id $serverProcess.Id -Force -ErrorAction SilentlyContinue
        
        # Check test results
        if (-not $success) {
            Write-Error "HTTP test failed on all addresses"
            Write-Host "Final process status:"
            Get-Process | Where-Object { $_.Id -eq $serverProcess.Id } | Format-List
            Write-Host "Final log content:"
            Get-Content "server_error.log"
            Get-Content "server_output.log"
            exit 1
        }
      working-directory: Server

    # Build Client
    - name: Create Client Build Directory
      run: |
        if (Test-Path build) { Remove-Item build -Recurse -Force }
        mkdir build
      working-directory: Client

    - name: Configure Client QMake
      run: |
        qmake ..\Client.pro -spec win32-msvc "CONFIG+=test"
      working-directory: Client/build

    - name: Build Client
      run: |
        nmake
      working-directory: Client/build

    - name: Deploy Client
      run: |
        if (Test-Path deploy) { Remove-Item deploy -Recurse -Force }
        mkdir deploy
        copy build\release\Client.exe deploy\
        windeployqt deploy\Client.exe
      working-directory: Client

    # Test Client
    - name: Test Client
      run: |
        # Verify required files exist
        $requiredFiles = @(
            "deploy\Client.exe",
            "deploy\Qt6Core.dll",
            "deploy\Qt6Gui.dll",
            "deploy\Qt6Multimedia.dll"
        )
        
        foreach ($file in $requiredFiles) {
            if (-not (Test-Path $file)) {
                Write-Error "Missing required file: $file"
                exit 1
            }
        }
        
        Write-Host "All required files present"
      working-directory: Client

    # Create combined deployment directory
    - name: Create Combined Deploy Directory
      run: |
        if (Test-Path deploy) { Remove-Item deploy -Recurse -Force }
        mkdir deploy
        mkdir deploy\Server
        mkdir deploy\Client
        Copy-Item Server\deploy\* deploy\Server\ -Recurse
        Copy-Item Client\deploy\* deploy\Client\ -Recurse
        
        # Create README.txt
        @"
        Track Application
        =================

        Installation:
        1. Extract all files
        2. Run Server\Server.exe first
        3. Run Client\Client.exe

        System Requirements:
        - Windows 10 or later
        - At least 4GB RAM
        - DirectX 11 or later
        "@ | Out-File -FilePath deploy\README.txt -Encoding UTF8

    # Upload combined artifact
    - name: Upload Combined Artifact
      uses: actions/upload-artifact@v4
      with:
        name: Track-Windows
        path: deploy/

    # Create Release
    - name: Create Release
      if: startsWith(github.ref, 'refs/tags/')
      uses: softprops/action-gh-release@v1
      with:
        files: deploy/**/*
        name: Release ${{ github.ref_name }}
        body: |
          ## What's Changed
          * Automated release from tag ${{ github.ref_name }}
          
          ## Installation
          1. Download and extract the archive
          2. Run Server\Server.exe first
          3. Run Client\Client.exe
          
          ## System Requirements
          * Windows 10 or later
          * At least 4GB RAM
          * DirectX 11 or later
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    # Notify on Discord
    - name: Discord Notification
      if: always()
      uses: sarisia/actions-status-discord@v1
      with:
        webhook: ${{ secrets.DISCORD_WEBHOOK }}
        status: ${{ job.status }}
        title: "Build Result"
        description: |
          Branch: ${{ github.ref_name }}
          Commit: ${{ github.sha }}
          
          Download artifacts from:
          ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        ack_no_webhook: true  # Suppress error when webhook is not configured