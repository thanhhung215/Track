name: Build Qt Application

on:
  push:
    branches: [ main ]
    tags:
      - 'v*'
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: windows-latest

    steps:
    - uses: actions/checkout@v3

    - name: Install Qt
      uses: jurplel/install-qt-action@v3
      with:
        version: '6.5.3'
        host: 'windows'
        target: 'desktop'
        arch: 'win64_msvc2019_64'
        tools: 'tools_qtcreator'
        modules: 'qtwebsockets qtwebchannel qtwebengine qtwebview qthttpserver qtmultimedia'
        cache: true

    - name: Set up MSVC
      uses: microsoft/setup-msbuild@v1.1

    - name: Setup Visual Studio Environment
      uses: ilammy/msvc-dev-cmd@v1
      with:
        arch: x64

    # Build Server
    - name: Create Server Build Directory
      run: |
        if (Test-Path build) { Remove-Item build -Recurse -Force }
        mkdir build
      working-directory: Server

    - name: Configure Server QMake
      run: |
        qmake ..\Server.pro -spec win32-msvc "CONFIG+=test"
      working-directory: Server/build

    - name: Build Server
      run: |
        nmake
      working-directory: Server/build

    - name: Deploy Server
      run: |
        if (Test-Path deploy) { Remove-Item deploy -Recurse -Force }
        mkdir deploy
        copy build\release\Server.exe deploy\
        windeployqt deploy\Server.exe
      working-directory: Server

    # Test Server
    - name: Test Server
      run: |
        # Create necessary directories and files
        Write-Host "Setting up required directories and files..."
        
        # Create base directories
        $baseDir = "deploy"
        $dirs = @(
            "$baseDir\account",
            "$baseDir\timesheet",
            "$baseDir\data",
            "$baseDir\status\$((Get-Date).ToString('yyyy-MM-dd'))"
        )
        
        foreach ($dir in $dirs) {
            New-Item -ItemType Directory -Force -Path $dir
        }
        
        # Create initial JSON files
        $files = @{
            "$baseDir\account\account.json" = '{"users": []}'
            "$baseDir\timesheet\timesheet.json" = '{"entries": []}'
            "$baseDir\data\points.json" = '{"points": {}}'
            "$baseDir\status\$((Get-Date).ToString('yyyy-MM-dd'))\status.json" = '{"status": []}'
        }
        
        foreach ($file in $files.Keys) {
            Set-Content -Path $file -Value $files[$file]
        }
        
        Write-Host "Directory structure created:"
        Get-ChildItem -Path "deploy" -Recurse
        
        # Start Server with output redirection
        $serverProcess = Start-Process -FilePath "deploy\Server.exe" -WorkingDirectory "deploy" -PassThru -RedirectStandardOutput "server_output.log" -RedirectStandardError "server_error.log" -NoNewWindow
        
        Write-Host "Server process started with PID: $($serverProcess.Id)"
        Write-Host "Waiting for server to initialize..."
        
        # Wait and check for server startup in logs
        $maxWait = 30
        $waited = 0
        $serverStarted = $false
        $serverIP = ""
        while ($waited -lt $maxWait -and -not $serverStarted) {
            # Check both output and server.log
            $logContent = Get-Content "server_output.log" -ErrorAction SilentlyContinue
            $serverLogContent = Get-Content "deploy\server.log" -ErrorAction SilentlyContinue
            
            # Show current log content for debugging
            Write-Host "Current server log content (${waited}s):"
            if ($serverLogContent) { 
                Write-Host $serverLogContent
                
                # Split log content into lines
                $logLines = $serverLogContent -split ' '
                foreach ($line in $logLines) {
                    if ($line -match 'http://([0-9.]+):8080') {
                        $serverIP = $matches[1]
                        $serverStarted = $true
                        Write-Host "Server startup detected in logs at IP: $serverIP"
                        break
                    }
                }
                
                if (-not $serverStarted -and ($serverLogContent -match 'HTTP server is listening on port')) {
                    # If we see the listening message but no IP, use the first available IP
                    $networkIP = Get-NetIPAddress -AddressFamily IPv4 | 
                        Where-Object { $_.IPAddress -like "172.*" -or $_.IPAddress -like "10.*" } | 
                        Select-Object -First 1 -ExpandProperty IPAddress
                    if ($networkIP) {
                        $serverIP = $networkIP
                        $serverStarted = $true
                        Write-Host "Using network adapter IP: $serverIP"
                        break
                    }
                }
            }
            
            Start-Sleep -Seconds 1
            $waited++
        }
        
        if (-not $serverStarted) {
            Write-Error "Server did not start properly within $maxWait seconds"
            Write-Host "Process status:"
            Get-Process | Where-Object { $_.Id -eq $serverProcess.Id } | Format-List
            Write-Host "Final server log content:"
            Get-Content "deploy\server.log" -ErrorAction SilentlyContinue
            Write-Host "Network interfaces:"
            ipconfig /all
            Write-Host "Active TCP Listeners:"
            netstat -ano | Select-String "LISTENING"
            exit 1
        }
        
        # Try to connect using the extracted IP
        Write-Host "Testing connection to $serverIP`:8080"
        try {
            $response = Invoke-WebRequest -Uri "http://$serverIP`:8080" -TimeoutSec 5
            if ($response.StatusCode -eq 200) {
                Write-Host "Successfully connected to $serverIP`:8080"
                Write-Host "Response: $($response.Content)"
            } else {
                Write-Error "Received unexpected status code: $($response.StatusCode)"
                exit 1
            }
        }
        catch {
            Write-Error "Failed to connect to $serverIP`:8080: $_"
            Write-Host "Network interfaces:"
            ipconfig /all
            Write-Host "Active TCP Listeners:"
            netstat -ano | Select-String "LISTENING"
            exit 1
        }
        
        # Kill Server process
        Stop-Process -Id $serverProcess.Id -Force -ErrorAction SilentlyContinue
      working-directory: Server

    # Build Client
    - name: Create Client Build Directory
      run: |
        if (Test-Path build) { Remove-Item build -Recurse -Force }
        mkdir build
      working-directory: Client

    - name: Configure Client QMake
      run: |
        qmake ..\Client.pro -spec win32-msvc "CONFIG+=test"
      working-directory: Client/build

    - name: Build Client
      run: |
        nmake
      working-directory: Client/build

    - name: Deploy Client
      run: |
        if (Test-Path deploy) { Remove-Item deploy -Recurse -Force }
        mkdir deploy
        copy build\release\Client.exe deploy\
        windeployqt deploy\Client.exe
      working-directory: Client

    # Test Client
    - name: Test Client
      run: |
        # Create test directory structure
        $testDir = "test_environment"
        New-Item -ItemType Directory -Force -Path $testDir
        
        # Start Server in background
        $serverProcess = Start-Process -FilePath "..\Server\deploy\Server.exe" -WorkingDirectory "..\Server\deploy" -PassThru -RedirectStandardOutput "server_output.log" -RedirectStandardError "server_error.log" -NoNewWindow
        
        Write-Host "Server started with PID: $($serverProcess.Id)"
        Start-Sleep -Seconds 5  # Wait for server to initialize
        
        # Start Client with logging
        Write-Host "Starting Client with logging..."
        $clientProcess = Start-Process -FilePath "deploy\Client.exe" -WorkingDirectory "deploy" -PassThru -RedirectStandardOutput "client_output.log" -RedirectStandardError "client_error.log" -NoNewWindow
        
        Write-Host "Client started with PID: $($clientProcess.Id)"
        Start-Sleep -Seconds 5  # Wait for client to initialize
        
        # Test basic functionality
        $testCases = @(
            @{
                "name" = "Registration"
                "data" = @{
                    "username" = "testuser"
                    "password" = "testpass"
                }
            }
            @{
                "name" = "Login"
                "data" = @{
                    "username" = "testuser"
                    "password" = "testpass"
                }
            }
            # Add more test cases as needed
        )
        
        Write-Host "Running functional tests..."
        foreach ($test in $testCases) {
            Write-Host "Testing: $($test.name)"
            # Add test implementation here
        }
        
        # Check logs for errors
        Write-Host "Checking Client logs..."
        $clientLogs = Get-Content "client_output.log" -ErrorAction SilentlyContinue
        if ($clientLogs) {
            Write-Host "Client logs:"
            Write-Host $clientLogs
        }
        
        $clientErrors = Get-Content "client_error.log" -ErrorAction SilentlyContinue
        if ($clientErrors) {
            Write-Host "Client errors:"
            Write-Host $clientErrors
            exit 1
        }
        
        # Cleanup
        Stop-Process -Id $clientProcess.Id -Force -ErrorAction SilentlyContinue
        Stop-Process -Id $serverProcess.Id -Force -ErrorAction SilentlyContinue
        
        # Verify required files exist and have content
        $requiredFiles = @(
            "deploy\Client.exe",
            "deploy\Qt6Core.dll",
            "deploy\Qt6Gui.dll",
            "deploy\Qt6Multimedia.dll",
            "client_output.log"
        )
        
        foreach ($file in $requiredFiles) {
            if (-not (Test-Path $file)) {
                Write-Error "Missing required file: $file"
                exit 1
            }
            
            if ($file -eq "client_output.log") {
                $content = Get-Content $file
                if (-not $content) {
                    Write-Error "Client log file is empty"
                    exit 1
                }
            }
        }
        
        Write-Host "All tests completed successfully"
      working-directory: Client

    # Create combined deployment directory
    - name: Create Combined Deploy Directory
      run: |
        if (Test-Path deploy) { Remove-Item deploy -Recurse -Force }
        mkdir deploy
        mkdir deploy\Server
        mkdir deploy\Client
        Copy-Item Server\deploy\* deploy\Server\ -Recurse
        Copy-Item Client\deploy\* deploy\Client\ -Recurse
        
        # Create README.txt
        @"
        Track Application
        =================

        Installation:
        1. Extract all files
        2. Run Server\Server.exe first
        3. Run Client\Client.exe

        System Requirements:
        - Windows 10 or later
        - At least 4GB RAM
        - DirectX 11 or later
        "@ | Out-File -FilePath deploy\README.txt -Encoding UTF8

    # Upload combined artifact
    - name: Upload Combined Artifact
      uses: actions/upload-artifact@v4
      with:
        name: Track-Windows
        path: deploy/

    # Create Release
    - name: Create Release
      if: startsWith(github.ref, 'refs/tags/')
      uses: softprops/action-gh-release@v1
      with:
        files: deploy/**/*
        name: Release ${{ github.ref_name }}
        body: |
          ## What's Changed
          * Automated release from tag ${{ github.ref_name }}
          
          ## Installation
          1. Download and extract the archive
          2. Run Server\Server.exe first
          3. Run Client\Client.exe
          
          ## System Requirements
          * Windows 10 or later
          * At least 4GB RAM
          * DirectX 11 or later
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    # Notify on Discord
    - name: Discord Notification
      if: always()
      uses: sarisia/actions-status-discord@v1
      with:
        webhook: ${{ secrets.DISCORD_WEBHOOK }}
        status: ${{ job.status }}
        title: "Build Result"
        description: |
          Branch: ${{ github.ref_name }}
          Commit: ${{ github.sha }}
          
          Download artifacts from:
          ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        ack_no_webhook: true  # Suppress error when webhook is not configured